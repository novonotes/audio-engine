// *********************************************************
// DO NOT EDIT THIS FILE.
// This file is generated by the audio_engine_protoc_plugin.
// Any changes to this file will be lost.
//
// template: controller_template.dart
// source: novonotes/audio_engine/v1alpha1/transport.proto
// *********************************************************

import 'dart:async';

import 'package:audio_engine/src/constants.dart';
import 'package:audio_engine/src/controller_request_executor.dart';
import 'package:audio_engine/src/engine_message_channel.dart';
import 'package:audio_engine/src/logger.dart';
import 'package:flutter/foundation.dart';
import 'package:nam/nam.dart';

import 'package:audio_engine/src/generated/google/protobuf/struct.pb.dart'
    as pb;
import 'transport.pb.dart' as pb;
import './type/body_type.pb.dart' as pb;
import './type/engine_error.pb.dart' as pb;

class TransportController {
  final ControllerRequestExecutor _requestExecutor;

  /// EngineController のインスタンスを使わなくなった場合、このメソッドをつかってポートの close やリソース解放などの終了処理を行う
  Future<void> dispose() async {
    await _subscription.cancel();
  }

  late StreamSubscription<Message> _subscription;

  TransportController(EngineMessageChannel channel)
      : _requestExecutor = ControllerRequestExecutor(channel) {
    _subscription =
        channel.receivedMessages.handleError((Object e, StackTrace s) {
      if (kDebugMode) {
        Logger.log(e);
        Logger.log("\n$s");
      }
    }).listen(
      (msg) {
        final body = msg.body;
        final contextStruct = pb.Struct.fromBuffer(msg.context);
        final context = contextStruct.toProto3Json() as Map<String, dynamic>;
        final requestId = (context["request-id"] as double).toInt();
        final bodyType = pb.BodyType.valueOf(msg.bodyType);
        if (bodyType == null) {
          _requestExecutor.handleError(
            Exception(
              "Engine sent a response with unsupported body type (${msg.bodyType}).",
            ),
            requestId,
          );
        }

        // Error の場合

        if (bodyType == pb.BodyType.BODY_TYPE_ENGINE_ERROR) {
          final error = pb.EngineError.fromBuffer(body);
          _requestExecutor.handleError(error, requestId);
          return;
        }

        // Response の場合
        if (bodyType == pb.BodyType.BODY_TYPE_UPDATE_TRANSPORT_RESPONSE) {
          final res = pb.UpdateTransportResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType == pb.BodyType.BODY_TYPE_START_PLAYBACK_RESPONSE) {
          final res = pb.StartPlaybackResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType == pb.BodyType.BODY_TYPE_STOP_PLAYBACK_RESPONSE) {
          final res = pb.StopPlaybackResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType ==
            pb.BodyType.BODY_TYPE_START_PLAYHEAD_POSITION_STREAM_RESPONSE) {
          final res = pb.StartPlayheadPositionStreamResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType ==
            pb.BodyType.BODY_TYPE_STOP_PLAYHEAD_POSITION_STREAM_RESPONSE) {
          final res = pb.StopPlayheadPositionStreamResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }
      },
    );
  }

  Future<pb.UpdateTransportResponse> updateTransport(
    pb.UpdateTransportRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.StartPlaybackResponse> startPlayback(
    pb.StartPlaybackRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.StopPlaybackResponse> stopPlayback(
    pb.StopPlaybackRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.StartPlayheadPositionStreamResponse> startPlayheadPositionStream(
    pb.StartPlayheadPositionStreamRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.StopPlayheadPositionStreamResponse> stopPlayheadPositionStream(
    pb.StopPlayheadPositionStreamRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }
}
