// *********************************************************
// DO NOT EDIT THIS FILE.
// This file is generated by the audio_engine_protoc_plugin.
// Any changes to this file will be lost.
//
// template: controller_template.dart
// source: novonotes/audio_engine/v1alpha1/engine_management.proto
// *********************************************************

import 'dart:async';

import 'package:audio_engine/src/constants.dart';
import 'package:audio_engine/src/controller_request_executor.dart';
import 'package:audio_engine/src/engine_message_channel.dart';
import 'package:audio_engine/src/logger.dart';
import 'package:flutter/foundation.dart';
import 'package:nam/nam.dart';

import 'package:audio_engine/src/generated/google/protobuf/struct.pb.dart'
    as pb;
import 'engine_management.pb.dart' as pb;
import './type/body_type.pb.dart' as pb;
import './type/engine_error.pb.dart' as pb;

class EngineManagementController {
  final ControllerRequestExecutor _requestExecutor;

  /// EngineController のインスタンスを使わなくなった場合、このメソッドをつかってポートの close やリソース解放などの終了処理を行う
  Future<void> dispose() async {
    await _subscription.cancel();
  }

  late StreamSubscription<Message> _subscription;

  EngineManagementController(EngineMessageChannel channel)
      : _requestExecutor = ControllerRequestExecutor(channel) {
    _subscription =
        channel.receivedMessages.handleError((Object e, StackTrace s) {
      if (kDebugMode) {
        Logger.log(e);
        Logger.log("\n$s");
      }
    }).listen(
      (msg) {
        final body = msg.body;
        final contextStruct = pb.Struct.fromBuffer(msg.context);
        final context = contextStruct.toProto3Json() as Map<String, dynamic>;
        final requestId = (context["request-id"] as double).toInt();
        final bodyType = pb.BodyType.valueOf(msg.bodyType);
        if (bodyType == null) {
          _requestExecutor.handleError(
            Exception(
              "Engine sent a response with unsupported body type (${msg.bodyType}).",
            ),
            requestId,
          );
        }

        // Error の場合

        if (bodyType == pb.BodyType.BODY_TYPE_ENGINE_ERROR) {
          final error = pb.EngineError.fromBuffer(body);
          _requestExecutor.handleError(error, requestId);
          return;
        }

        // Response の場合
        if (bodyType == pb.BodyType.BODY_TYPE_INITIALIZE_RESPONSE) {
          final res = pb.InitializeResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType == pb.BodyType.BODY_TYPE_SHUTDOWN_RESPONSE) {
          final res = pb.ShutdownResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType == pb.BodyType.BODY_TYPE_RESET_STATE_RESPONSE) {
          final res = pb.ResetStateResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }

        if (bodyType == pb.BodyType.BODY_TYPE_PLAY_TEST_TONE_RESPONSE) {
          final res = pb.PlayTestToneResponse.fromBuffer(body);
          _requestExecutor.handleResponse(res, requestId);
          return;
        }
      },
    );
  }

  Future<pb.InitializeResponse> initialize(
    pb.InitializeRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.ShutdownResponse> shutdown(
    pb.ShutdownRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.ResetStateResponse> resetState(
    pb.ResetStateRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }

  Future<pb.PlayTestToneResponse> playTestTone(
    pb.PlayTestToneRequest req, {
    Duration timeout = defaultRequestTimeout,
  }) async {
    return _requestExecutor.execute(
      req,
      SchemaVersion.v1alpha1,
      timeout: timeout,
    );
  }
}
