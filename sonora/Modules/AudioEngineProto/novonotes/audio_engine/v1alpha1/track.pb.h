// Generated by the protocol buffer compiler.  DO NOT EDIT!
// NO CHECKED-IN PROTOBUF GENCODE
// source: novonotes/audio_engine/v1alpha1/track.proto
// Protobuf C++ Version: 5.28.1

#ifndef GOOGLE_PROTOBUF_INCLUDED_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto_2epb_2eh
#define GOOGLE_PROTOBUF_INCLUDED_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto_2epb_2eh

#include <limits>
#include <string>
#include <type_traits>
#include <utility>

#include "google/protobuf/runtime_version.h"
#if PROTOBUF_VERSION != 5028001
#error "Protobuf C++ gencode is built with an incompatible version of"
#error "Protobuf C++ headers/runtime. See"
#error "https://protobuf.dev/support/cross-version-runtime-guarantee/#cpp"
#endif
#include "google/api/field_behavior.pb.h"
#include "google/api/resource.pb.h"
#include "google/protobuf/arena.h"
#include "google/protobuf/arenastring.h"
#include "google/protobuf/extension_set.h"  // IWYU pragma: export
#include "google/protobuf/generated_enum_reflection.h"
#include "google/protobuf/generated_message_bases.h"
#include "google/protobuf/generated_message_reflection.h"
#include "google/protobuf/generated_message_tctable_decl.h"
#include "google/protobuf/generated_message_util.h"
#include "google/protobuf/io/coded_stream.h"
#include "google/protobuf/message.h"
#include "google/protobuf/metadata_lite.h"
#include "google/protobuf/repeated_field.h"  // IWYU pragma: export
#include "google/protobuf/unknown_field_set.h"
// @@protoc_insertion_point(includes)

// Must be included last.
#include "google/protobuf/port_def.inc"

#define PROTOBUF_INTERNAL_EXPORT_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto

namespace google
{
namespace protobuf
{
namespace internal
{
class AnyMetadata;
}  // namespace internal
}  // namespace protobuf
}  // namespace google

// Internal implementation detail -- do not use these members.
struct TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto
{
    static const ::uint32_t offsets[];
};
extern const ::google::protobuf::internal::DescriptorTable
    descriptor_table_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
namespace novonotes
{
namespace audio_engine
{
namespace v1alpha1
{
class CreateTrackRequest;
struct CreateTrackRequestDefaultTypeInternal;
extern CreateTrackRequestDefaultTypeInternal
    _CreateTrackRequest_default_instance_;
class CreateTrackResponse;
struct CreateTrackResponseDefaultTypeInternal;
extern CreateTrackResponseDefaultTypeInternal
    _CreateTrackResponse_default_instance_;
class DeleteTrackRequest;
struct DeleteTrackRequestDefaultTypeInternal;
extern DeleteTrackRequestDefaultTypeInternal
    _DeleteTrackRequest_default_instance_;
class DeleteTrackResponse;
struct DeleteTrackResponseDefaultTypeInternal;
extern DeleteTrackResponseDefaultTypeInternal
    _DeleteTrackResponse_default_instance_;
class Track;
struct TrackDefaultTypeInternal;
extern TrackDefaultTypeInternal _Track_default_instance_;
class UpdateTrackRequest;
struct UpdateTrackRequestDefaultTypeInternal;
extern UpdateTrackRequestDefaultTypeInternal
    _UpdateTrackRequest_default_instance_;
class UpdateTrackResponse;
struct UpdateTrackResponseDefaultTypeInternal;
extern UpdateTrackResponseDefaultTypeInternal
    _UpdateTrackResponse_default_instance_;
}  // namespace v1alpha1
}  // namespace audio_engine
}  // namespace novonotes
namespace google
{
namespace protobuf
{}  // namespace protobuf
}  // namespace google

namespace novonotes
{
namespace audio_engine
{
namespace v1alpha1
{
enum Track_TrackType : int
{
    Track_TrackType_TRACK_TYPE_UNSPECIFIED = 0,
    Track_TrackType_TRACK_TYPE_AUDIO = 1,
    Track_TrackType_TRACK_TYPE_MIDI = 2,
    Track_TrackType_Track_TrackType_INT_MIN_SENTINEL_DO_NOT_USE_ =
        std::numeric_limits<::int32_t>::min(),
    Track_TrackType_Track_TrackType_INT_MAX_SENTINEL_DO_NOT_USE_ =
        std::numeric_limits<::int32_t>::max(),
};

bool Track_TrackType_IsValid(int value);
extern const uint32_t Track_TrackType_internal_data_[];
constexpr Track_TrackType Track_TrackType_TrackType_MIN =
    static_cast<Track_TrackType>(0);
constexpr Track_TrackType Track_TrackType_TrackType_MAX =
    static_cast<Track_TrackType>(2);
constexpr int Track_TrackType_TrackType_ARRAYSIZE = 2 + 1;
const ::google::protobuf::EnumDescriptor* Track_TrackType_descriptor();
template <typename T>
const std::string& Track_TrackType_Name(T value)
{
    static_assert(
        std::is_same<T, Track_TrackType>::value || std::is_integral<T>::value,
        "Incorrect type passed to TrackType_Name().");
    return Track_TrackType_Name(static_cast<Track_TrackType>(value));
}
template <>
inline const std::string& Track_TrackType_Name(Track_TrackType value)
{
    return ::google::protobuf::internal::NameOfDenseEnum<
        Track_TrackType_descriptor, 0, 2>(static_cast<int>(value));
}
inline bool Track_TrackType_Parse(absl::string_view name,
                                  Track_TrackType* value)
{
    return ::google::protobuf::internal::ParseNamedEnum<Track_TrackType>(
        Track_TrackType_descriptor(), name, value);
}

// ===================================================================

// -------------------------------------------------------------------

class UpdateTrackResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.UpdateTrackResponse)
 */
{
   public:
    inline UpdateTrackResponse() : UpdateTrackResponse(nullptr) {}
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR UpdateTrackResponse(
        ::google::protobuf::internal::ConstantInitialized);

    inline UpdateTrackResponse(const UpdateTrackResponse& from)
        : UpdateTrackResponse(nullptr, from)
    {}
    inline UpdateTrackResponse(UpdateTrackResponse&& from) noexcept
        : UpdateTrackResponse(nullptr, std::move(from))
    {}
    inline UpdateTrackResponse& operator=(const UpdateTrackResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UpdateTrackResponse& operator=(UpdateTrackResponse&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const UpdateTrackResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UpdateTrackResponse* internal_default_instance()
    {
        return reinterpret_cast<const UpdateTrackResponse*>(
            &_UpdateTrackResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 4;
    friend void swap(UpdateTrackResponse& a, UpdateTrackResponse& b)
    {
        a.Swap(&b);
    }
    inline void Swap(UpdateTrackResponse* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UpdateTrackResponse* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UpdateTrackResponse* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<
            UpdateTrackResponse>(arena);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
    inline void CopyFrom(const UpdateTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
    void MergeFrom(const UpdateTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
    }

   public:
    bool IsInitialized() const { return true; }

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.UpdateTrackResponse";
    }

   protected:
    explicit UpdateTrackResponse(::google::protobuf::Arena* arena);
    UpdateTrackResponse(::google::protobuf::Arena* arena,
                        const UpdateTrackResponse& from);
    UpdateTrackResponse(::google::protobuf::Arena* arena,
                        UpdateTrackResponse&& from) noexcept
        : UpdateTrackResponse(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::internal::ZeroFieldsBase::ClassData*
    GetClassData() const PROTOBUF_FINAL;
    static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull
        _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.UpdateTrackResponse)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 0, 0, 0, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_UpdateTrackResponse_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const UpdateTrackResponse& from_msg);
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class Track final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.Track)
 */
{
   public:
    inline Track() : Track(nullptr) {}
    ~Track() PROTOBUF_FINAL;
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR Track(
        ::google::protobuf::internal::ConstantInitialized);

    inline Track(const Track& from) : Track(nullptr, from) {}
    inline Track(Track&& from) noexcept : Track(nullptr, std::move(from)) {}
    inline Track& operator=(const Track& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline Track& operator=(Track&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const Track& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const Track* internal_default_instance()
    {
        return reinterpret_cast<const Track*>(&_Track_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 0;
    friend void swap(Track& a, Track& b) { a.Swap(&b); }
    inline void Swap(Track* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(Track* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    Track* New(::google::protobuf::Arena* arena = nullptr) const PROTOBUF_FINAL
    {
        return ::google::protobuf::Message::DefaultConstruct<Track>(arena);
    }
    using ::google::protobuf::Message::CopyFrom;
    void CopyFrom(const Track& from);
    using ::google::protobuf::Message::MergeFrom;
    void MergeFrom(const Track& from) { Track::MergeImpl(*this, from); }

   private:
    static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                          const ::google::protobuf::MessageLite& from_msg);

   public:
    bool IsInitialized() const { return true; }
    ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
#if defined(PROTOBUF_CUSTOM_VTABLE)
   private:
    static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
    static ::uint8_t* _InternalSerialize(
        const MessageLite& msg, ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream);

   public:
    ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const
    {
        return _InternalSerialize(*this, target, stream);
    }
#else   // PROTOBUF_CUSTOM_VTABLE
    ::size_t ByteSizeLong() const final;
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
#endif  // PROTOBUF_CUSTOM_VTABLE
    int GetCachedSize() const { return _impl_._cached_size_.Get(); }

   private:
    void SharedCtor(::google::protobuf::Arena* arena);
    void SharedDtor();
    void InternalSwap(Track* other);

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.Track";
    }

   protected:
    explicit Track(::google::protobuf::Arena* arena);
    Track(::google::protobuf::Arena* arena, const Track& from);
    Track(::google::protobuf::Arena* arena, Track&& from) noexcept
        : Track(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::Message::ClassData* GetClassData() const
        PROTOBUF_FINAL;
    static const ::google::protobuf::Message::ClassDataFull _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------
    using TrackType = Track_TrackType;
    static constexpr TrackType TRACK_TYPE_UNSPECIFIED =
        Track_TrackType_TRACK_TYPE_UNSPECIFIED;
    static constexpr TrackType TRACK_TYPE_AUDIO =
        Track_TrackType_TRACK_TYPE_AUDIO;
    static constexpr TrackType TRACK_TYPE_MIDI =
        Track_TrackType_TRACK_TYPE_MIDI;
    static inline bool TrackType_IsValid(int value)
    {
        return Track_TrackType_IsValid(value);
    }
    static constexpr TrackType TrackType_MIN = Track_TrackType_TrackType_MIN;
    static constexpr TrackType TrackType_MAX = Track_TrackType_TrackType_MAX;
    static constexpr int TrackType_ARRAYSIZE =
        Track_TrackType_TrackType_ARRAYSIZE;
    static inline const ::google::protobuf::EnumDescriptor*
    TrackType_descriptor()
    {
        return Track_TrackType_descriptor();
    }
    template <typename T>
    static inline const std::string& TrackType_Name(T value)
    {
        return Track_TrackType_Name(value);
    }
    static inline bool TrackType_Parse(absl::string_view name, TrackType* value)
    {
        return Track_TrackType_Parse(name, value);
    }

    // accessors -------------------------------------------------------
    enum : int
    {
        kIdFieldNumber = 1,
        kTypeFieldNumber = 2,
    };
    // string id = 1 [(.google.api.field_behavior) = IDENTIFIER,
    // (.google.api.field_behavior) = REQUIRED];
    void clear_id();
    const std::string& id() const;
    template <typename Arg_ = const std::string&, typename... Args_>
    void set_id(Arg_&& arg, Args_... args);
    std::string* mutable_id();
    PROTOBUF_NODISCARD std::string* release_id();
    void set_allocated_id(std::string* value);

   private:
    const std::string& _internal_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_id(
        const std::string& value);
    std::string* _internal_mutable_id();

   public:
    // .novonotes.audio_engine.v1alpha1.Track.TrackType type = 2
    // [(.google.api.field_behavior) = REQUIRED];
    void clear_type();
    ::novonotes::audio_engine::v1alpha1::Track_TrackType type() const;
    void set_type(::novonotes::audio_engine::v1alpha1::Track_TrackType value);

   private:
    ::novonotes::audio_engine::v1alpha1::Track_TrackType _internal_type() const;
    void _internal_set_type(
        ::novonotes::audio_engine::v1alpha1::Track_TrackType value);

   public:
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.Track)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<1, 2, 0, 48, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_Track_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const Track& from_msg);
        ::google::protobuf::internal::ArenaStringPtr id_;
        int type_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    union
    {
        Impl_ _impl_;
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class DeleteTrackResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.DeleteTrackResponse)
 */
{
   public:
    inline DeleteTrackResponse() : DeleteTrackResponse(nullptr) {}
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR DeleteTrackResponse(
        ::google::protobuf::internal::ConstantInitialized);

    inline DeleteTrackResponse(const DeleteTrackResponse& from)
        : DeleteTrackResponse(nullptr, from)
    {}
    inline DeleteTrackResponse(DeleteTrackResponse&& from) noexcept
        : DeleteTrackResponse(nullptr, std::move(from))
    {}
    inline DeleteTrackResponse& operator=(const DeleteTrackResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DeleteTrackResponse& operator=(DeleteTrackResponse&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const DeleteTrackResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DeleteTrackResponse* internal_default_instance()
    {
        return reinterpret_cast<const DeleteTrackResponse*>(
            &_DeleteTrackResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 6;
    friend void swap(DeleteTrackResponse& a, DeleteTrackResponse& b)
    {
        a.Swap(&b);
    }
    inline void Swap(DeleteTrackResponse* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DeleteTrackResponse* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DeleteTrackResponse* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<
            DeleteTrackResponse>(arena);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
    inline void CopyFrom(const DeleteTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
    void MergeFrom(const DeleteTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
    }

   public:
    bool IsInitialized() const { return true; }

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.DeleteTrackResponse";
    }

   protected:
    explicit DeleteTrackResponse(::google::protobuf::Arena* arena);
    DeleteTrackResponse(::google::protobuf::Arena* arena,
                        const DeleteTrackResponse& from);
    DeleteTrackResponse(::google::protobuf::Arena* arena,
                        DeleteTrackResponse&& from) noexcept
        : DeleteTrackResponse(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::internal::ZeroFieldsBase::ClassData*
    GetClassData() const PROTOBUF_FINAL;
    static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull
        _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.DeleteTrackResponse)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 0, 0, 0, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_DeleteTrackResponse_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const DeleteTrackResponse& from_msg);
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class DeleteTrackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.DeleteTrackRequest)
 */
{
   public:
    inline DeleteTrackRequest() : DeleteTrackRequest(nullptr) {}
    ~DeleteTrackRequest() PROTOBUF_FINAL;
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR DeleteTrackRequest(
        ::google::protobuf::internal::ConstantInitialized);

    inline DeleteTrackRequest(const DeleteTrackRequest& from)
        : DeleteTrackRequest(nullptr, from)
    {}
    inline DeleteTrackRequest(DeleteTrackRequest&& from) noexcept
        : DeleteTrackRequest(nullptr, std::move(from))
    {}
    inline DeleteTrackRequest& operator=(const DeleteTrackRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline DeleteTrackRequest& operator=(DeleteTrackRequest&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const DeleteTrackRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const DeleteTrackRequest* internal_default_instance()
    {
        return reinterpret_cast<const DeleteTrackRequest*>(
            &_DeleteTrackRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 5;
    friend void swap(DeleteTrackRequest& a, DeleteTrackRequest& b)
    {
        a.Swap(&b);
    }
    inline void Swap(DeleteTrackRequest* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(DeleteTrackRequest* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    DeleteTrackRequest* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::Message::DefaultConstruct<
            DeleteTrackRequest>(arena);
    }
    using ::google::protobuf::Message::CopyFrom;
    void CopyFrom(const DeleteTrackRequest& from);
    using ::google::protobuf::Message::MergeFrom;
    void MergeFrom(const DeleteTrackRequest& from)
    {
        DeleteTrackRequest::MergeImpl(*this, from);
    }

   private:
    static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                          const ::google::protobuf::MessageLite& from_msg);

   public:
    bool IsInitialized() const { return true; }
    ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
#if defined(PROTOBUF_CUSTOM_VTABLE)
   private:
    static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
    static ::uint8_t* _InternalSerialize(
        const MessageLite& msg, ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream);

   public:
    ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const
    {
        return _InternalSerialize(*this, target, stream);
    }
#else   // PROTOBUF_CUSTOM_VTABLE
    ::size_t ByteSizeLong() const final;
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
#endif  // PROTOBUF_CUSTOM_VTABLE
    int GetCachedSize() const { return _impl_._cached_size_.Get(); }

   private:
    void SharedCtor(::google::protobuf::Arena* arena);
    void SharedDtor();
    void InternalSwap(DeleteTrackRequest* other);

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.DeleteTrackRequest";
    }

   protected:
    explicit DeleteTrackRequest(::google::protobuf::Arena* arena);
    DeleteTrackRequest(::google::protobuf::Arena* arena,
                       const DeleteTrackRequest& from);
    DeleteTrackRequest(::google::protobuf::Arena* arena,
                       DeleteTrackRequest&& from) noexcept
        : DeleteTrackRequest(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::Message::ClassData* GetClassData() const
        PROTOBUF_FINAL;
    static const ::google::protobuf::Message::ClassDataFull _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    enum : int
    {
        kTrackIdFieldNumber = 1,
    };
    // string track_id = 1 [(.google.api.field_behavior) = REQUIRED];
    void clear_track_id();
    const std::string& track_id() const;
    template <typename Arg_ = const std::string&, typename... Args_>
    void set_track_id(Arg_&& arg, Args_... args);
    std::string* mutable_track_id();
    PROTOBUF_NODISCARD std::string* release_track_id();
    void set_allocated_track_id(std::string* value);

   private:
    const std::string& _internal_track_id() const;
    inline PROTOBUF_ALWAYS_INLINE void _internal_set_track_id(
        const std::string& value);
    std::string* _internal_mutable_track_id();

   public:
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.DeleteTrackRequest)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 1, 0, 67, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_DeleteTrackRequest_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const DeleteTrackRequest& from_msg);
        ::google::protobuf::internal::ArenaStringPtr track_id_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    union
    {
        Impl_ _impl_;
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class CreateTrackResponse final
    : public ::google::protobuf::internal::ZeroFieldsBase
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.CreateTrackResponse)
 */
{
   public:
    inline CreateTrackResponse() : CreateTrackResponse(nullptr) {}
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR CreateTrackResponse(
        ::google::protobuf::internal::ConstantInitialized);

    inline CreateTrackResponse(const CreateTrackResponse& from)
        : CreateTrackResponse(nullptr, from)
    {}
    inline CreateTrackResponse(CreateTrackResponse&& from) noexcept
        : CreateTrackResponse(nullptr, std::move(from))
    {}
    inline CreateTrackResponse& operator=(const CreateTrackResponse& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CreateTrackResponse& operator=(CreateTrackResponse&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const CreateTrackResponse& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CreateTrackResponse* internal_default_instance()
    {
        return reinterpret_cast<const CreateTrackResponse*>(
            &_CreateTrackResponse_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 2;
    friend void swap(CreateTrackResponse& a, CreateTrackResponse& b)
    {
        a.Swap(&b);
    }
    inline void Swap(CreateTrackResponse* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CreateTrackResponse* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CreateTrackResponse* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::internal::ZeroFieldsBase::DefaultConstruct<
            CreateTrackResponse>(arena);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::CopyFrom;
    inline void CopyFrom(const CreateTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::CopyImpl(*this, from);
    }
    using ::google::protobuf::internal::ZeroFieldsBase::MergeFrom;
    void MergeFrom(const CreateTrackResponse& from)
    {
        ::google::protobuf::internal::ZeroFieldsBase::MergeImpl(*this, from);
    }

   public:
    bool IsInitialized() const { return true; }

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.CreateTrackResponse";
    }

   protected:
    explicit CreateTrackResponse(::google::protobuf::Arena* arena);
    CreateTrackResponse(::google::protobuf::Arena* arena,
                        const CreateTrackResponse& from);
    CreateTrackResponse(::google::protobuf::Arena* arena,
                        CreateTrackResponse&& from) noexcept
        : CreateTrackResponse(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::internal::ZeroFieldsBase::ClassData*
    GetClassData() const PROTOBUF_FINAL;
    static const ::google::protobuf::internal::ZeroFieldsBase::ClassDataFull
        _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.CreateTrackResponse)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 0, 0, 0, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_CreateTrackResponse_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const CreateTrackResponse& from_msg);
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class UpdateTrackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.UpdateTrackRequest)
 */
{
   public:
    inline UpdateTrackRequest() : UpdateTrackRequest(nullptr) {}
    ~UpdateTrackRequest() PROTOBUF_FINAL;
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR UpdateTrackRequest(
        ::google::protobuf::internal::ConstantInitialized);

    inline UpdateTrackRequest(const UpdateTrackRequest& from)
        : UpdateTrackRequest(nullptr, from)
    {}
    inline UpdateTrackRequest(UpdateTrackRequest&& from) noexcept
        : UpdateTrackRequest(nullptr, std::move(from))
    {}
    inline UpdateTrackRequest& operator=(const UpdateTrackRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline UpdateTrackRequest& operator=(UpdateTrackRequest&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const UpdateTrackRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const UpdateTrackRequest* internal_default_instance()
    {
        return reinterpret_cast<const UpdateTrackRequest*>(
            &_UpdateTrackRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 3;
    friend void swap(UpdateTrackRequest& a, UpdateTrackRequest& b)
    {
        a.Swap(&b);
    }
    inline void Swap(UpdateTrackRequest* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(UpdateTrackRequest* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    UpdateTrackRequest* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::Message::DefaultConstruct<
            UpdateTrackRequest>(arena);
    }
    using ::google::protobuf::Message::CopyFrom;
    void CopyFrom(const UpdateTrackRequest& from);
    using ::google::protobuf::Message::MergeFrom;
    void MergeFrom(const UpdateTrackRequest& from)
    {
        UpdateTrackRequest::MergeImpl(*this, from);
    }

   private:
    static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                          const ::google::protobuf::MessageLite& from_msg);

   public:
    bool IsInitialized() const { return true; }
    ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
#if defined(PROTOBUF_CUSTOM_VTABLE)
   private:
    static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
    static ::uint8_t* _InternalSerialize(
        const MessageLite& msg, ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream);

   public:
    ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const
    {
        return _InternalSerialize(*this, target, stream);
    }
#else   // PROTOBUF_CUSTOM_VTABLE
    ::size_t ByteSizeLong() const final;
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
#endif  // PROTOBUF_CUSTOM_VTABLE
    int GetCachedSize() const { return _impl_._cached_size_.Get(); }

   private:
    void SharedCtor(::google::protobuf::Arena* arena);
    void SharedDtor();
    void InternalSwap(UpdateTrackRequest* other);

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.UpdateTrackRequest";
    }

   protected:
    explicit UpdateTrackRequest(::google::protobuf::Arena* arena);
    UpdateTrackRequest(::google::protobuf::Arena* arena,
                       const UpdateTrackRequest& from);
    UpdateTrackRequest(::google::protobuf::Arena* arena,
                       UpdateTrackRequest&& from) noexcept
        : UpdateTrackRequest(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::Message::ClassData* GetClassData() const
        PROTOBUF_FINAL;
    static const ::google::protobuf::Message::ClassDataFull _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    enum : int
    {
        kTrackFieldNumber = 1,
    };
    // .novonotes.audio_engine.v1alpha1.Track track = 1
    // [(.google.api.field_behavior) = REQUIRED];
    bool has_track() const;
    void clear_track();
    const ::novonotes::audio_engine::v1alpha1::Track& track() const;
    PROTOBUF_NODISCARD ::novonotes::audio_engine::v1alpha1::Track*
    release_track();
    ::novonotes::audio_engine::v1alpha1::Track* mutable_track();
    void set_allocated_track(::novonotes::audio_engine::v1alpha1::Track* value);
    void unsafe_arena_set_allocated_track(
        ::novonotes::audio_engine::v1alpha1::Track* value);
    ::novonotes::audio_engine::v1alpha1::Track* unsafe_arena_release_track();

   private:
    const ::novonotes::audio_engine::v1alpha1::Track& _internal_track() const;
    ::novonotes::audio_engine::v1alpha1::Track* _internal_mutable_track();

   public:
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.UpdateTrackRequest)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_UpdateTrackRequest_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const UpdateTrackRequest& from_msg);
        ::google::protobuf::internal::HasBits<1> _has_bits_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        ::novonotes::audio_engine::v1alpha1::Track* track_;
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    union
    {
        Impl_ _impl_;
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};
// -------------------------------------------------------------------

class CreateTrackRequest final : public ::google::protobuf::Message
/* @@protoc_insertion_point(class_definition:novonotes.audio_engine.v1alpha1.CreateTrackRequest)
 */
{
   public:
    inline CreateTrackRequest() : CreateTrackRequest(nullptr) {}
    ~CreateTrackRequest() PROTOBUF_FINAL;
    template <typename = void>
    explicit PROTOBUF_CONSTEXPR CreateTrackRequest(
        ::google::protobuf::internal::ConstantInitialized);

    inline CreateTrackRequest(const CreateTrackRequest& from)
        : CreateTrackRequest(nullptr, from)
    {}
    inline CreateTrackRequest(CreateTrackRequest&& from) noexcept
        : CreateTrackRequest(nullptr, std::move(from))
    {}
    inline CreateTrackRequest& operator=(const CreateTrackRequest& from)
    {
        CopyFrom(from);
        return *this;
    }
    inline CreateTrackRequest& operator=(CreateTrackRequest&& from) noexcept
    {
        if(this == &from) return *this;
        if(GetArena() == from.GetArena()
#ifdef PROTOBUF_FORCE_COPY_IN_MOVE
           && GetArena() != nullptr
#endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
        )
        {
            InternalSwap(&from);
        }
        else
        {
            CopyFrom(from);
        }
        return *this;
    }

    inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .unknown_fields<::google::protobuf::UnknownFieldSet>(
                ::google::protobuf::UnknownFieldSet::default_instance);
    }
    inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields()
        ABSL_ATTRIBUTE_LIFETIME_BOUND
    {
        return _internal_metadata_
            .mutable_unknown_fields<::google::protobuf::UnknownFieldSet>();
    }

    static const ::google::protobuf::Descriptor* descriptor()
    {
        return GetDescriptor();
    }
    static const ::google::protobuf::Descriptor* GetDescriptor()
    {
        return default_instance().GetMetadata().descriptor;
    }
    static const ::google::protobuf::Reflection* GetReflection()
    {
        return default_instance().GetMetadata().reflection;
    }
    static const CreateTrackRequest& default_instance()
    {
        return *internal_default_instance();
    }
    static inline const CreateTrackRequest* internal_default_instance()
    {
        return reinterpret_cast<const CreateTrackRequest*>(
            &_CreateTrackRequest_default_instance_);
    }
    static constexpr int kIndexInFileMessages = 1;
    friend void swap(CreateTrackRequest& a, CreateTrackRequest& b)
    {
        a.Swap(&b);
    }
    inline void Swap(CreateTrackRequest* other)
    {
        if(other == this) return;
#ifdef PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() != nullptr && GetArena() == other->GetArena())
        {
#else   // PROTOBUF_FORCE_COPY_IN_SWAP
        if(GetArena() == other->GetArena())
        {
#endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
            InternalSwap(other);
        }
        else
        {
            ::google::protobuf::internal::GenericSwap(this, other);
        }
    }
    void UnsafeArenaSwap(CreateTrackRequest* other)
    {
        if(other == this) return;
        ABSL_DCHECK(GetArena() == other->GetArena());
        InternalSwap(other);
    }

    // implements Message ----------------------------------------------

    CreateTrackRequest* New(::google::protobuf::Arena* arena = nullptr) const
        PROTOBUF_FINAL
    {
        return ::google::protobuf::Message::DefaultConstruct<
            CreateTrackRequest>(arena);
    }
    using ::google::protobuf::Message::CopyFrom;
    void CopyFrom(const CreateTrackRequest& from);
    using ::google::protobuf::Message::MergeFrom;
    void MergeFrom(const CreateTrackRequest& from)
    {
        CreateTrackRequest::MergeImpl(*this, from);
    }

   private:
    static void MergeImpl(::google::protobuf::MessageLite& to_msg,
                          const ::google::protobuf::MessageLite& from_msg);

   public:
    bool IsInitialized() const { return true; }
    ABSL_ATTRIBUTE_REINITIALIZES void Clear() PROTOBUF_FINAL;
#if defined(PROTOBUF_CUSTOM_VTABLE)
   private:
    static ::size_t ByteSizeLong(const ::google::protobuf::MessageLite& msg);
    static ::uint8_t* _InternalSerialize(
        const MessageLite& msg, ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream);

   public:
    ::size_t ByteSizeLong() const { return ByteSizeLong(*this); }
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const
    {
        return _InternalSerialize(*this, target, stream);
    }
#else   // PROTOBUF_CUSTOM_VTABLE
    ::size_t ByteSizeLong() const final;
    ::uint8_t* _InternalSerialize(
        ::uint8_t* target,
        ::google::protobuf::io::EpsCopyOutputStream* stream) const final;
#endif  // PROTOBUF_CUSTOM_VTABLE
    int GetCachedSize() const { return _impl_._cached_size_.Get(); }

   private:
    void SharedCtor(::google::protobuf::Arena* arena);
    void SharedDtor();
    void InternalSwap(CreateTrackRequest* other);

   private:
    friend class ::google::protobuf::internal::AnyMetadata;
    static ::absl::string_view FullMessageName()
    {
        return "novonotes.audio_engine.v1alpha1.CreateTrackRequest";
    }

   protected:
    explicit CreateTrackRequest(::google::protobuf::Arena* arena);
    CreateTrackRequest(::google::protobuf::Arena* arena,
                       const CreateTrackRequest& from);
    CreateTrackRequest(::google::protobuf::Arena* arena,
                       CreateTrackRequest&& from) noexcept
        : CreateTrackRequest(arena)
    {
        *this = ::std::move(from);
    }
    const ::google::protobuf::Message::ClassData* GetClassData() const
        PROTOBUF_FINAL;
    static const ::google::protobuf::Message::ClassDataFull _class_data_;

   public:
    ::google::protobuf::Metadata GetMetadata() const;
    // nested types ----------------------------------------------------

    // accessors -------------------------------------------------------
    enum : int
    {
        kTrackFieldNumber = 1,
    };
    // .novonotes.audio_engine.v1alpha1.Track track = 1
    // [(.google.api.field_behavior) = REQUIRED];
    bool has_track() const;
    void clear_track();
    const ::novonotes::audio_engine::v1alpha1::Track& track() const;
    PROTOBUF_NODISCARD ::novonotes::audio_engine::v1alpha1::Track*
    release_track();
    ::novonotes::audio_engine::v1alpha1::Track* mutable_track();
    void set_allocated_track(::novonotes::audio_engine::v1alpha1::Track* value);
    void unsafe_arena_set_allocated_track(
        ::novonotes::audio_engine::v1alpha1::Track* value);
    ::novonotes::audio_engine::v1alpha1::Track* unsafe_arena_release_track();

   private:
    const ::novonotes::audio_engine::v1alpha1::Track& _internal_track() const;
    ::novonotes::audio_engine::v1alpha1::Track* _internal_mutable_track();

   public:
    // @@protoc_insertion_point(class_scope:novonotes.audio_engine.v1alpha1.CreateTrackRequest)
   private:
    class _Internal;
    friend class ::google::protobuf::internal::TcParser;
    static const ::google::protobuf::internal::TcParseTable<0, 1, 1, 0, 2>
        _table_;

    static constexpr const void* _raw_default_instance_ =
        &_CreateTrackRequest_default_instance_;

    friend class ::google::protobuf::MessageLite;
    friend class ::google::protobuf::Arena;
    template <typename T>
    friend class ::google::protobuf::Arena::InternalHelper;
    using InternalArenaConstructable_ = void;
    using DestructorSkippable_ = void;
    struct Impl_
    {
        inline explicit constexpr Impl_(
            ::google::protobuf::internal::ConstantInitialized) noexcept;
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena);
        inline explicit Impl_(
            ::google::protobuf::internal::InternalVisibility visibility,
            ::google::protobuf::Arena* arena, const Impl_& from,
            const CreateTrackRequest& from_msg);
        ::google::protobuf::internal::HasBits<1> _has_bits_;
        mutable ::google::protobuf::internal::CachedSize _cached_size_;
        ::novonotes::audio_engine::v1alpha1::Track* track_;
        PROTOBUF_TSAN_DECLARE_MEMBER
    };
    union
    {
        Impl_ _impl_;
    };
    friend struct ::
        TableStruct_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto;
};

// ===================================================================

// ===================================================================

#ifdef __GNUC__
#pragma GCC diagnostic push
#pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// Track

// string id = 1 [(.google.api.field_behavior) = IDENTIFIER,
// (.google.api.field_behavior) = REQUIRED];
inline void Track::clear_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.id_.ClearToEmpty();
}
inline const std::string& Track::id() const ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    // @@protoc_insertion_point(field_get:novonotes.audio_engine.v1alpha1.Track.id)
    return _internal_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void Track::set_id(Arg_&& arg, Args_... args)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
    // @@protoc_insertion_point(field_set:novonotes.audio_engine.v1alpha1.Track.id)
}
inline std::string* Track::mutable_id() ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    std::string* _s = _internal_mutable_id();
    // @@protoc_insertion_point(field_mutable:novonotes.audio_engine.v1alpha1.Track.id)
    return _s;
}
inline const std::string& Track::_internal_id() const
{
    ::google::protobuf::internal::TSanRead(&_impl_);
    return _impl_.id_.Get();
}
inline void Track::_internal_set_id(const std::string& value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.id_.Set(value, GetArena());
}
inline std::string* Track::_internal_mutable_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    return _impl_.id_.Mutable(GetArena());
}
inline std::string* Track::release_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    // @@protoc_insertion_point(field_release:novonotes.audio_engine.v1alpha1.Track.id)
    return _impl_.id_.Release();
}
inline void Track::set_allocated_id(std::string* value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.id_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if(_impl_.id_.IsDefault())
    {
        _impl_.id_.Set("", GetArena());
    }
#endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:novonotes.audio_engine.v1alpha1.Track.id)
}

// .novonotes.audio_engine.v1alpha1.Track.TrackType type = 2
// [(.google.api.field_behavior) = REQUIRED];
inline void Track::clear_type()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.type_ = 0;
}
inline ::novonotes::audio_engine::v1alpha1::Track_TrackType Track::type() const
{
    // @@protoc_insertion_point(field_get:novonotes.audio_engine.v1alpha1.Track.type)
    return _internal_type();
}
inline void Track::set_type(
    ::novonotes::audio_engine::v1alpha1::Track_TrackType value)
{
    _internal_set_type(value);
    // @@protoc_insertion_point(field_set:novonotes.audio_engine.v1alpha1.Track.type)
}
inline ::novonotes::audio_engine::v1alpha1::Track_TrackType
Track::_internal_type() const
{
    ::google::protobuf::internal::TSanRead(&_impl_);
    return static_cast<::novonotes::audio_engine::v1alpha1::Track_TrackType>(
        _impl_.type_);
}
inline void Track::_internal_set_type(
    ::novonotes::audio_engine::v1alpha1::Track_TrackType value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.type_ = value;
}

// -------------------------------------------------------------------

// CreateTrackRequest

// .novonotes.audio_engine.v1alpha1.Track track = 1
// [(.google.api.field_behavior) = REQUIRED];
inline bool CreateTrackRequest::has_track() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
    return value;
}
inline void CreateTrackRequest::clear_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(_impl_.track_ != nullptr) _impl_.track_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::novonotes::audio_engine::v1alpha1::Track&
CreateTrackRequest::_internal_track() const
{
    ::google::protobuf::internal::TSanRead(&_impl_);
    const ::novonotes::audio_engine::v1alpha1::Track* p = _impl_.track_;
    return p != nullptr
               ? *p
               : reinterpret_cast<
                     const ::novonotes::audio_engine::v1alpha1::Track&>(
                     ::novonotes::audio_engine::v1alpha1::
                         _Track_default_instance_);
}
inline const ::novonotes::audio_engine::v1alpha1::Track&
CreateTrackRequest::track() const ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    // @@protoc_insertion_point(field_get:novonotes.audio_engine.v1alpha1.CreateTrackRequest.track)
    return _internal_track();
}
inline void CreateTrackRequest::unsafe_arena_set_allocated_track(
    ::novonotes::audio_engine::v1alpha1::Track* value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(GetArena() == nullptr)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite*>(
            _impl_.track_);
    }
    _impl_.track_ =
        reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(value);
    if(value != nullptr)
    {
        _impl_._has_bits_[0] |= 0x00000001u;
    }
    else
    {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:novonotes.audio_engine.v1alpha1.CreateTrackRequest.track)
}
inline ::novonotes::audio_engine::v1alpha1::Track*
CreateTrackRequest::release_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);

    _impl_._has_bits_[0] &= ~0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* released = _impl_.track_;
    _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if(GetArena() == nullptr)
    {
        delete old;
    }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
    if(GetArena() != nullptr)
    {
        released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return released;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
CreateTrackRequest::unsafe_arena_release_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    // @@protoc_insertion_point(field_release:novonotes.audio_engine.v1alpha1.CreateTrackRequest.track)

    _impl_._has_bits_[0] &= ~0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* temp = _impl_.track_;
    _impl_.track_ = nullptr;
    return temp;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
CreateTrackRequest::_internal_mutable_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(_impl_.track_ == nullptr)
    {
        auto* p = ::google::protobuf::Message::DefaultConstruct<
            ::novonotes::audio_engine::v1alpha1::Track>(GetArena());
        _impl_.track_ =
            reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(p);
    }
    return _impl_.track_;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
CreateTrackRequest::mutable_track() ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    _impl_._has_bits_[0] |= 0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* _msg =
        _internal_mutable_track();
    // @@protoc_insertion_point(field_mutable:novonotes.audio_engine.v1alpha1.CreateTrackRequest.track)
    return _msg;
}
inline void CreateTrackRequest::set_allocated_track(
    ::novonotes::audio_engine::v1alpha1::Track* value)
{
    ::google::protobuf::Arena* message_arena = GetArena();
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(message_arena == nullptr)
    {
        delete(_impl_.track_);
    }

    if(value != nullptr)
    {
        ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
        if(message_arena != submessage_arena)
        {
            value = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, value, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    }
    else
    {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }

    _impl_.track_ =
        reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(value);
    // @@protoc_insertion_point(field_set_allocated:novonotes.audio_engine.v1alpha1.CreateTrackRequest.track)
}

// -------------------------------------------------------------------

// CreateTrackResponse

// -------------------------------------------------------------------

// UpdateTrackRequest

// .novonotes.audio_engine.v1alpha1.Track track = 1
// [(.google.api.field_behavior) = REQUIRED];
inline bool UpdateTrackRequest::has_track() const
{
    bool value = (_impl_._has_bits_[0] & 0x00000001u) != 0;
    PROTOBUF_ASSUME(!value || _impl_.track_ != nullptr);
    return value;
}
inline void UpdateTrackRequest::clear_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(_impl_.track_ != nullptr) _impl_.track_->Clear();
    _impl_._has_bits_[0] &= ~0x00000001u;
}
inline const ::novonotes::audio_engine::v1alpha1::Track&
UpdateTrackRequest::_internal_track() const
{
    ::google::protobuf::internal::TSanRead(&_impl_);
    const ::novonotes::audio_engine::v1alpha1::Track* p = _impl_.track_;
    return p != nullptr
               ? *p
               : reinterpret_cast<
                     const ::novonotes::audio_engine::v1alpha1::Track&>(
                     ::novonotes::audio_engine::v1alpha1::
                         _Track_default_instance_);
}
inline const ::novonotes::audio_engine::v1alpha1::Track&
UpdateTrackRequest::track() const ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    // @@protoc_insertion_point(field_get:novonotes.audio_engine.v1alpha1.UpdateTrackRequest.track)
    return _internal_track();
}
inline void UpdateTrackRequest::unsafe_arena_set_allocated_track(
    ::novonotes::audio_engine::v1alpha1::Track* value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(GetArena() == nullptr)
    {
        delete reinterpret_cast<::google::protobuf::MessageLite*>(
            _impl_.track_);
    }
    _impl_.track_ =
        reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(value);
    if(value != nullptr)
    {
        _impl_._has_bits_[0] |= 0x00000001u;
    }
    else
    {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }
    // @@protoc_insertion_point(field_unsafe_arena_set_allocated:novonotes.audio_engine.v1alpha1.UpdateTrackRequest.track)
}
inline ::novonotes::audio_engine::v1alpha1::Track*
UpdateTrackRequest::release_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);

    _impl_._has_bits_[0] &= ~0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* released = _impl_.track_;
    _impl_.track_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
    auto* old = reinterpret_cast<::google::protobuf::MessageLite*>(released);
    released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    if(GetArena() == nullptr)
    {
        delete old;
    }
#else   // PROTOBUF_FORCE_COPY_IN_RELEASE
    if(GetArena() != nullptr)
    {
        released = ::google::protobuf::internal::DuplicateIfNonNull(released);
    }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
    return released;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
UpdateTrackRequest::unsafe_arena_release_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    // @@protoc_insertion_point(field_release:novonotes.audio_engine.v1alpha1.UpdateTrackRequest.track)

    _impl_._has_bits_[0] &= ~0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* temp = _impl_.track_;
    _impl_.track_ = nullptr;
    return temp;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
UpdateTrackRequest::_internal_mutable_track()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(_impl_.track_ == nullptr)
    {
        auto* p = ::google::protobuf::Message::DefaultConstruct<
            ::novonotes::audio_engine::v1alpha1::Track>(GetArena());
        _impl_.track_ =
            reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(p);
    }
    return _impl_.track_;
}
inline ::novonotes::audio_engine::v1alpha1::Track*
UpdateTrackRequest::mutable_track() ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    _impl_._has_bits_[0] |= 0x00000001u;
    ::novonotes::audio_engine::v1alpha1::Track* _msg =
        _internal_mutable_track();
    // @@protoc_insertion_point(field_mutable:novonotes.audio_engine.v1alpha1.UpdateTrackRequest.track)
    return _msg;
}
inline void UpdateTrackRequest::set_allocated_track(
    ::novonotes::audio_engine::v1alpha1::Track* value)
{
    ::google::protobuf::Arena* message_arena = GetArena();
    ::google::protobuf::internal::TSanWrite(&_impl_);
    if(message_arena == nullptr)
    {
        delete(_impl_.track_);
    }

    if(value != nullptr)
    {
        ::google::protobuf::Arena* submessage_arena = (value)->GetArena();
        if(message_arena != submessage_arena)
        {
            value = ::google::protobuf::internal::GetOwnedMessage(
                message_arena, value, submessage_arena);
        }
        _impl_._has_bits_[0] |= 0x00000001u;
    }
    else
    {
        _impl_._has_bits_[0] &= ~0x00000001u;
    }

    _impl_.track_ =
        reinterpret_cast<::novonotes::audio_engine::v1alpha1::Track*>(value);
    // @@protoc_insertion_point(field_set_allocated:novonotes.audio_engine.v1alpha1.UpdateTrackRequest.track)
}

// -------------------------------------------------------------------

// UpdateTrackResponse

// -------------------------------------------------------------------

// DeleteTrackRequest

// string track_id = 1 [(.google.api.field_behavior) = REQUIRED];
inline void DeleteTrackRequest::clear_track_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.track_id_.ClearToEmpty();
}
inline const std::string& DeleteTrackRequest::track_id() const
    ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    // @@protoc_insertion_point(field_get:novonotes.audio_engine.v1alpha1.DeleteTrackRequest.track_id)
    return _internal_track_id();
}
template <typename Arg_, typename... Args_>
inline PROTOBUF_ALWAYS_INLINE void DeleteTrackRequest::set_track_id(
    Arg_&& arg, Args_... args)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.track_id_.Set(static_cast<Arg_&&>(arg), args..., GetArena());
    // @@protoc_insertion_point(field_set:novonotes.audio_engine.v1alpha1.DeleteTrackRequest.track_id)
}
inline std::string* DeleteTrackRequest::mutable_track_id()
    ABSL_ATTRIBUTE_LIFETIME_BOUND
{
    std::string* _s = _internal_mutable_track_id();
    // @@protoc_insertion_point(field_mutable:novonotes.audio_engine.v1alpha1.DeleteTrackRequest.track_id)
    return _s;
}
inline const std::string& DeleteTrackRequest::_internal_track_id() const
{
    ::google::protobuf::internal::TSanRead(&_impl_);
    return _impl_.track_id_.Get();
}
inline void DeleteTrackRequest::_internal_set_track_id(const std::string& value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.track_id_.Set(value, GetArena());
}
inline std::string* DeleteTrackRequest::_internal_mutable_track_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    return _impl_.track_id_.Mutable(GetArena());
}
inline std::string* DeleteTrackRequest::release_track_id()
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    // @@protoc_insertion_point(field_release:novonotes.audio_engine.v1alpha1.DeleteTrackRequest.track_id)
    return _impl_.track_id_.Release();
}
inline void DeleteTrackRequest::set_allocated_track_id(std::string* value)
{
    ::google::protobuf::internal::TSanWrite(&_impl_);
    _impl_.track_id_.SetAllocated(value, GetArena());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    if(_impl_.track_id_.IsDefault())
    {
        _impl_.track_id_.Set("", GetArena());
    }
#endif  // PROTOBUF_FORCE_COPY_DEFAULT_STRING
    // @@protoc_insertion_point(field_set_allocated:novonotes.audio_engine.v1alpha1.DeleteTrackRequest.track_id)
}

// -------------------------------------------------------------------

// DeleteTrackResponse

#ifdef __GNUC__
#pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)
}  // namespace v1alpha1
}  // namespace audio_engine
}  // namespace novonotes

namespace google
{
namespace protobuf
{

template <>
struct is_proto_enum<::novonotes::audio_engine::v1alpha1::Track_TrackType>
    : std::true_type
{};
template <>
inline const EnumDescriptor*
GetEnumDescriptor<::novonotes::audio_engine::v1alpha1::Track_TrackType>()
{
    return ::novonotes::audio_engine::v1alpha1::Track_TrackType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include "google/protobuf/port_undef.inc"

#endif  // GOOGLE_PROTOBUF_INCLUDED_novonotes_2faudio_5fengine_2fv1alpha1_2ftrack_2eproto_2epb_2eh
